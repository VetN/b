G = {
    "Адмиралтейская": {
        "Садовая": 4},
    "Садовая": {
        "Сенная площадь": 4,
        "Спасская": 3,
        "Адмиралтейская": 4,
        "Звенигородская": 5},
    "Сенная площадь": {
        "Садовая": 4,
        "Спасская": 4},
    "Спасская": {
        "Садовая": 3,
        "Сенная площадь": 4,
        "Достоевская": 6},
    "Звенигородская": {
        "Пушкинская": 3,
        "Садовая": 5},
    "Пушкинская": {
        "Звенигородская": 3,
        "Владимирская": 4},
    "Владимирская": {
        "Достоевская": 3,
        "Пушкинская": 4},
    "Достоевская": {
        "Владимирская": 3,
        "Спасская": 6}
}
# создаем словарь для хранения расстояний ставим 100 расстояние заведомо больше любого максим знач
d = {k : 100 for k in G.keys()}

# берем стартовую вершину (предок для всех остальных)
#D["Адмиралтейская"] = 0
start_k = "Адмиралтейская"
d[start_k] = 0

# создаем словарь для хранения булев значен(true если вершина просмотрена)
u = {k : False for k in G.keys()}

# словарь в котором храним вершину-предок с минимальным расстоянием
p = {k : None for k in G.keys()}

# создаем цикл, выбирая наименьшее D из просмотренных
for _ in range(len(d)):
    min_k = min([k for k in u.keys() if not u[k]], key = lambda x: d[x])

    # перебираем все смежные вершины
    for v in G[min_k].keys():
        if d[v] > d[min_k] +G[min_k][v]:
            d[v] = min(d[v], d[min_k] + G[min_k][v]) # минимум фиксируем
            p[v] = min_k # записываем как предок
        u[min_k] = True # просмотренную вершину помечаем


    print("u", u)
    print('d', d)
    print(('p', p))
# цикл идет по вершинам в словаре р находим вершины кратчайшего пути
some_station = []
poin = some_station
    # идем пока не придем в стартовую точку
while poin is not None:
    print("poin", poin)
    poin = p[poin]